<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Neural Network</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f4f8; /* Light blue-gray background */
        }
        .neuron {
            transition: all 0.5s ease-in-out;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
        }
        .neuron.activated {
            transform: scale(1.1);
            box-shadow: 0 0 20px rgba(52, 152, 219, 0.7);
        }
        .connection {
            transition: stroke 0.5s ease-in-out, stroke-width 0.3s ease;
        }
        .connection.activated {
            stroke-dasharray: 10 5;
            animation: dash 1s linear infinite;
        }
        @keyframes dash {
            to {
                stroke-dashoffset: -15;
            }
        }
        .slider-container {
            transition: opacity 0.3s ease;
        }
        .info-box {
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
    </style>
</head>
<body class="bg-gray-50 text-gray-800 antialiased">
    <div class="min-h-screen flex flex-col items-center justify-center p-4 lg:p-8">

        <header class="text-center mb-8">
            <h1 class="text-4xl lg:text-5xl font-bold text-gray-900">A Basic Neural Network</h1>
            <p class="text-lg text-gray-600 mt-2 max-w-2xl mx-auto">An interactive animation to visualize how a simple neural network works.</p>
        </header>

        <div class="w-full max-w-6xl mx-auto flex flex-col lg:flex-row items-center justify-between gap-8">

            <!-- Neural Network Visualization -->
            <div id="visualization" class="relative w-full flex-grow flex justify-center items-center h-[400px] lg:h-[500px]">
                <!-- SVG for Connections -->
                <svg id="svg-canvas" class="absolute w-full h-full top-0 left-0 z-0" style="overflow: visible;"></svg>

                <!-- Layers -->
                <div class="relative z-10 w-full flex justify-between items-center px-4">
                    <!-- Input Layer -->
                    <div id="input-layer" class="flex flex-col gap-16">
                        <div class="text-center mb-4">
                            <h2 class="font-semibold text-lg">Input</h2>
                            <p class="text-sm text-gray-500">(Click to Toggle)</p>
                        </div>
                        <div id="input-neuron-0" class="neuron-container flex items-center gap-3">
                            <div class="neuron w-16 h-16 rounded-full bg-white border-2 border-green-400 flex items-center justify-center text-xl font-bold cursor-pointer" data-value="1" onclick="toggleInput(0)">1</div>
                            <span class="font-mono text-lg">x₁</span>
                        </div>
                         <div id="input-neuron-1" class="neuron-container flex items-center gap-3">
                            <div class="neuron w-16 h-16 rounded-full bg-white border-2 border-green-400 flex items-center justify-center text-xl font-bold cursor-pointer" data-value="1" onclick="toggleInput(1)">1</div>
                             <span class="font-mono text-lg">x₂</span>
                        </div>
                    </div>

                    <!-- Hidden Layer -->
                    <div id="hidden-layer" class="flex flex-col gap-8">
                         <div class="text-center mb-4">
                            <h2 class="font-semibold text-lg">Hidden Layer</h2>
                            <p class="text-sm text-gray-500">(Weights Applied)</p>
                        </div>
                        <div id="hidden-neuron-0" class="neuron-container flex items-center gap-3">
                             <div class="neuron w-20 h-20 rounded-full bg-white border-2 border-blue-400 flex flex-col items-center justify-center text-sm font-bold"><span class="value">0.00</span><span class="text-xs text-gray-400">σ(z)</span></div>
                        </div>
                         <div id="hidden-neuron-1" class="neuron-container flex items-center gap-3">
                             <div class="neuron w-20 h-20 rounded-full bg-white border-2 border-blue-400 flex flex-col items-center justify-center text-sm font-bold"><span class="value">0.00</span><span class="text-xs text-gray-400">σ(z)</span></div>
                        </div>
                        <div id="hidden-neuron-2" class="neuron-container flex items-center gap-3">
                             <div class="neuron w-20 h-20 rounded-full bg-white border-2 border-blue-400 flex flex-col items-center justify-center text-sm font-bold"><span class="value">0.00</span><span class="text-xs text-gray-400">σ(z)</span></div>
                        </div>
                    </div>

                    <!-- Output Layer -->
                    <div id="output-layer" class="flex flex-col gap-16">
                         <div class="text-center mb-4">
                            <h2 class="font-semibold text-lg">Output</h2>
                            <p class="text-sm text-gray-500">(Final Result)</p>
                        </div>
                        <div id="output-neuron-0" class="neuron-container flex items-center gap-3">
                            <div class="neuron w-24 h-24 rounded-full bg-white border-2 border-purple-400 flex flex-col items-center justify-center text-xl font-bold"><span class="value">0.00</span><span class="text-xs text-gray-400">σ(z)</span></div>
                        </div>
                    </div>
                </div>

                 <!-- Weight Sliders -->
                <div id="weight-sliders" class="absolute top-0 left-0 w-full h-full z-20"></div>
            </div>

            <!-- Controls and Explanation Panel -->
            <div class="w-full lg:w-96 flex-shrink-0">
                <div class="info-box bg-white/70 rounded-2xl shadow-lg p-6">
                    <h3 class="text-xl font-bold mb-4">How It Works</h3>
                    <div id="explanation" class="text-gray-700 space-y-3">
                        <p><strong>1. Inputs:</strong> Start by clicking the input nodes (green) to set their values to 0 or 1.</p>
                        <p><strong>2. Weights:</strong> Adjust the sliders on the connections to change their weights. A higher weight means a stronger signal.</p>
                        <p><strong>3. Propagate:</strong> Click the "Forward Propagate" button to send the signals through the network.</p>
                    </div>

                    <div class="mt-6 flex flex-col gap-4">
                         <button id="propagate-btn" class="w-full bg-blue-500 hover:bg-blue-600 text-white font-bold py-3 px-4 rounded-lg text-lg transition duration-300 shadow-md">
                            Forward Propagate
                        </button>
                        <button id="reset-btn" class="w-full bg-gray-500 hover:bg-gray-600 text-white font-bold py-2 px-4 rounded-lg transition duration-300">
                            Reset
                        </button>
                    </div>
                </div>

                <!-- Live Calculations Panel -->
                <div class="info-box bg-white/70 rounded-2xl shadow-lg p-6 mt-6">
                    <h3 class="text-xl font-bold mb-4">Live Calculations</h3>
                    <div id="math-explanation" class="text-gray-700 space-y-2 font-mono text-sm break-all">
                        <p class="text-gray-500">Calculations will appear here as the network runs...</p>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const visualization = document.getElementById('visualization');
            const svgCanvas = document.getElementById('svg-canvas');
            const weightSlidersContainer = document.getElementById('weight-sliders');
            const explanationDiv = document.getElementById('explanation');
            const mathExplanationDiv = document.getElementById('math-explanation');

            const layers = {
                input: [
                    { el: document.getElementById('input-neuron-0'), value: 1 },
                    { el: document.getElementById('input-neuron-1'), value: 1 }
                ],
                hidden: [
                    { el: document.getElementById('hidden-neuron-0'), value: 0 },
                    { el: document.getElementById('hidden-neuron-1'), value: 0 },
                    { el: document.getElementById('hidden-neuron-2'), value: 0 }
                ],
                output: [
                    { el: document.getElementById('output-neuron-0'), value: 0 }
                ]
            };

            const connections = [];
            let weights = {};

            // --- Initialization ---
            function initialize() {
                createConnections();
                drawConnections();
                createWeightSliders();
                updateExplanation("Welcome! Adjust inputs and weights, then press 'Forward Propagate' to see the magic.", false);
                updateMathExplanation('<p class="text-gray-500 !text-base">Calculations will appear here...</p>');
            }

            // --- Connection and Slider Creation ---
            function createConnections() {
                // Input -> Hidden
                for (let i = 0; i < layers.input.length; i++) {
                    for (let j = 0; j < layers.hidden.length; j++) {
                        const id = `w_i${i}h${j}`;
                        connections.push({ id, from: layers.input[i].el, to: layers.hidden[j].el, el: null });
                        weights[id] = Math.random() * 2 - 1; // Random weight between -1 and 1
                    }
                }
                // Hidden -> Output
                for (let i = 0; i < layers.hidden.length; i++) {
                    for (let j = 0; j < layers.output.length; j++) {
                        const id = `w_h${i}o${j}`;
                        connections.push({ id, from: layers.hidden[i].el, to: layers.output[j].el, el: null });
                        weights[id] = Math.random() * 2 - 1;
                    }
                }
            }

            function drawConnections() {
                svgCanvas.innerHTML = '';
                const vizRect = visualization.getBoundingClientRect();

                connections.forEach(conn => {
                    const fromRect = conn.from.getBoundingClientRect();
                    const toRect = conn.to.getBoundingClientRect();

                    const x1 = fromRect.right - vizRect.left;
                    const y1 = fromRect.top + fromRect.height / 2 - vizRect.top;
                    const x2 = toRect.left - vizRect.left;
                    const y2 = toRect.top + toRect.height / 2 - vizRect.top;

                    const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    line.setAttribute('x1', x1);
                    line.setAttribute('y1', y1);
                    line.setAttribute('x2', x2);
                    line.setAttribute('y2', y2);
                    line.setAttribute('stroke', '#9ca3af');
                    line.setAttribute('stroke-width', '2');
                    line.classList.add('connection');
                    svgCanvas.appendChild(line);
                    conn.el = line;
                });
            }

            function createWeightSliders() {
                weightSlidersContainer.innerHTML = '';
                 const vizRect = visualization.getBoundingClientRect();

                connections.forEach(conn => {
                    const fromRect = conn.from.getBoundingClientRect();
                    const toRect = conn.to.getBoundingClientRect();

                    const midX = (fromRect.right + toRect.left) / 2 - vizRect.left;
                    const midY = (fromRect.top + fromRect.height / 2 + toRect.top + toRect.height / 2) / 2 - vizRect.top;

                    const container = document.createElement('div');
                    container.classList.add('slider-container', 'absolute', 'flex', 'flex-col', 'items-center', 'transform', '-translate-x-1/2', '-translate-y-1/2', 'opacity-0', 'hover:opacity-100');
                    container.style.left = `${midX}px`;
                    container.style.top = `${midY}px`;

                    const slider = document.createElement('input');
                    slider.type = 'range';
                    slider.min = -1;
                    slider.max = 1;
                    slider.step = 0.01;
                    slider.value = weights[conn.id];
                    slider.classList.add('w-24', 'cursor-pointer');
                    slider.oninput = (e) => {
                        weights[conn.id] = parseFloat(e.target.value);
                        label.textContent = `w = ${weights[conn.id].toFixed(2)}`;
                        updateConnectionStyle(conn.id);
                    };

                    const label = document.createElement('span');
                    label.classList.add('text-xs', 'bg-gray-800', 'text-white', 'px-2', 'py-1', 'rounded-md', 'mt-1');
                    label.textContent = `w = ${weights[conn.id].toFixed(2)}`;

                    container.appendChild(slider);
                    container.appendChild(label);
                    weightSlidersContainer.appendChild(container);
                    updateConnectionStyle(conn.id);
                });
            }

            function updateConnectionStyle(connId) {
                const conn = connections.find(c => c.id === connId);
                if (!conn || !conn.el) return;

                const weight = weights[connId];
                const width = Math.abs(weight) * 4 + 1; // Width from 1 to 5
                const color = weight > 0 ? '#34d399' : '#f87171'; // Green for positive, red for negative

                conn.el.setAttribute('stroke-width', width);
                conn.el.setAttribute('stroke', color);
            }


            // --- Core Logic ---
            function sigmoid(x) {
                return 1 / (1 + Math.exp(-x));
            }

            async function forwardPropagate() {
                disableControls();
                resetActivations();
                updateMathExplanation('');
                await sleep(100);

                // Step 1: Activate Input Layer
                updateExplanation("<strong>Step 1:</strong> Input values are sent from the input layer.");
                updateMathExplanation(`<p>Inputs:</p><p class="text-green-600">x₁ = ${layers.input[0].value}, x₂ = ${layers.input[1].value}</p>`);
                layers.input.forEach(n => activateNeuron(n.el));
                await sleep(1000);

                // Step 2 & 3: Propagate to and Activate Hidden Layer
                updateExplanation("<strong>Step 2 & 3:</strong> Calculate weighted sum (z) for each hidden neuron and apply Sigmoid activation (σ).");
                let hiddenMathHtml = '';
                for (let i = 0; i < layers.hidden.length; i++) {
                    let weightedSum = 0;
                    let sumFormula = `z_h${i+1} = (x₁*wᵢ₁→ₕ${i+1}) + (x₂*wᵢ₂→ₕ${i+1})`;
                    let sumValues = `= (${layers.input[0].value} * ${weights[`w_i0h${i}`].toFixed(2)}) + (${layers.input[1].value} * ${weights[`w_i1h${i}`].toFixed(2)})`;

                    for (let j = 0; j < layers.input.length; j++) {
                         const connId = `w_i${j}h${i}`;
                         weightedSum += layers.input[j].value * weights[connId];
                         activateConnection(connId);
                    }
                    layers.hidden[i].weightedSum = weightedSum;

                    const activatedValue = sigmoid(weightedSum);
                    layers.hidden[i].value = activatedValue;

                    let sumResult = `= ${weightedSum.toFixed(3)}`;
                    let sigmoidFormula = `a_h${i+1} = σ(z_h${i+1}) = 1 / (1 + e<sup>-${weightedSum.toFixed(3)}</sup>)`;
                    let sigmoidResult = `= ${activatedValue.toFixed(3)}`;

                    hiddenMathHtml += `<div class="p-2 border rounded-md mt-2 bg-blue-50/50 border-blue-200">
                        <p class="font-bold text-blue-800">Hidden Neuron ${i+1}:</p>
                        <p>${sumFormula}</p>
                        <p>${sumValues}</p>
                        <p class="font-semibold">${sumResult}</p>
                        <p class="mt-2">${sigmoidFormula}</p>
                        <p class="font-semibold">${sigmoidResult}</p>
                    </div>`;

                    updateMathExplanation(hiddenMathHtml);
                    activateNeuron(layers.hidden[i].el, activatedValue);
                    await sleep(1000);
                }

                // Step 4 & 5: Propagate to and Activate Output Layer
                updateExplanation("<strong>Step 4 & 5:</strong> Calculate the final weighted sum using hidden layer outputs and activate.");

                let outputWeightedSum = 0;
                let outSumFormula = `z_o1 = (a_h1*wₕ₁→ₒ₁) + (a_h2*wₕ₂→ₒ₁) + (a_h3*wₕ₃→ₒ₁)`;
                let outSumValues = `= (${layers.hidden[0].value.toFixed(2)} * ${weights['w_h0o0'].toFixed(2)}) + (${layers.hidden[1].value.toFixed(2)} * ${weights['w_h1o0'].toFixed(2)}) + (${layers.hidden[2].value.toFixed(2)} * ${weights['w_h2o0'].toFixed(2)})`;

                for (let j = 0; j < layers.hidden.length; j++) {
                    const connId = `w_h${j}o0`;
                    outputWeightedSum += layers.hidden[j].value * weights[connId];
                    activateConnection(connId);
                }
                layers.output[0].weightedSum = outputWeightedSum;
                await sleep(1000);

                const finalValue = sigmoid(outputWeightedSum);
                layers.output[0].value = finalValue;
                activateNeuron(layers.output[0].el, finalValue);

                let outSumResult = `= ${outputWeightedSum.toFixed(3)}`;
                let outSigmoidFormula = `a_o1 = σ(z_o1) = 1 / (1 + e<sup>-${outputWeightedSum.toFixed(3)}</sup>)`;
                let outSigmoidResult = `= ${finalValue.toFixed(3)}`;

                let outputMathHtml = hiddenMathHtml + `<div class="p-2 border rounded-md mt-2 bg-purple-50/50 border-purple-200">
                    <p class="font-bold text-purple-800">Output Neuron:</p>
                    <p>${outSumFormula}</p>
                    <p>${outSumValues}</p>
                    <p class="font-semibold">${outSumResult}</p>
                    <p class="mt-2">${outSigmoidFormula}</p>
                    <p class="font-semibold">${outSigmoidResult}</p>
                </div>`;
                updateMathExplanation(outputMathHtml);

                await sleep(500);

                updateExplanation(`<strong>Done!</strong> The network's output is ${finalValue.toFixed(4)}. Try changing the inputs or weights and run again!`, true);
                enableControls();
            }

            // --- Animation and UI Helpers ---
            function updateMathExplanation(html) {
                mathExplanationDiv.innerHTML = html;
            }

            function updateExplanation(html, finished = false) {
                 if (finished) {
                     explanationDiv.innerHTML = `<p class="p-4 bg-green-100 border-l-4 border-green-500 rounded-r-lg">${html}</p>`;
                 } else {
                     explanationDiv.innerHTML = `<p>${html}</p>`;
                 }
            }

            function activateNeuron(el, value) {
                const innerEl = el.querySelector('.neuron') || el;
                innerEl.classList.add('activated');

                const colorIntensity = value !== undefined ? Math.round(value * 200) + 55 : 255;
                if(el.id.includes('hidden')) {
                     innerEl.style.backgroundColor = `rgb(59, 130, 246, ${value})`; // Blue
                } else if (el.id.includes('output')) {
                     innerEl.style.backgroundColor = `rgb(168, 85, 247, ${value})`; // Purple
                } else {
                     innerEl.style.backgroundColor = 'rgb(74, 222, 128)'; // Green
                }

                if (value !== undefined) {
                    const valueEl = innerEl.querySelector('.value');
                    if(valueEl) valueEl.textContent = value.toFixed(2);
                }
            }

            function activateConnection(connId) {
                const conn = connections.find(c => c.id === connId);
                if (conn && conn.el) {
                    conn.el.classList.add('activated');
                }
            }

            function resetActivations() {
                document.querySelectorAll('.neuron.activated, .neuron-container.activated').forEach(el => {
                    el.classList.remove('activated');
                    el.style.backgroundColor = 'white';
                });
                 document.querySelectorAll('.neuron').forEach(el => {
                     const valueEl = el.querySelector('.value');
                     if(valueEl) valueEl.textContent = '0.00';
                 });
                document.querySelectorAll('.connection.activated').forEach(el => el.classList.remove('activated'));
            }

            function resetAll() {
                resetActivations();
                // Reset weights to random values
                Object.keys(weights).forEach(id => {
                    weights[id] = Math.random() * 2 - 1;
                });
                createWeightSliders(); // Redraw sliders with new values
                updateExplanation("Network has been reset. Set your inputs and weights.", false);
                updateMathExplanation('<p class="text-gray-500 !text-base">Calculations will appear here...</p>');
            }

            function disableControls() {
                document.getElementById('propagate-btn').disabled = true;
                document.getElementById('propagate-btn').classList.add('opacity-50', 'cursor-not-allowed');
                document.getElementById('reset-btn').disabled = true;
                document.getElementById('reset-btn').classList.add('opacity-50', 'cursor-not-allowed');
                weightSlidersContainer.style.pointerEvents = 'none';
            }

            function enableControls() {
                document.getElementById('propagate-btn').disabled = false;
                document.getElementById('propagate-btn').classList.remove('opacity-50', 'cursor-not-allowed');
                document.getElementById('reset-btn').disabled = false;
                document.getElementById('reset-btn').classList.remove('opacity-50', 'cursor-not-allowed');
                weightSlidersContainer.style.pointerEvents = 'auto';
            }

            window.toggleInput = (index) => {
                const neuron = layers.input[index];
                const neuronDiv = neuron.el.querySelector('.neuron');
                const currentValue = parseInt(neuronDiv.dataset.value);
                const newValue = 1 - currentValue; // Toggle between 0 and 1

                neuron.value = newValue;
                neuronDiv.dataset.value = newValue;
                neuronDiv.textContent = newValue;

                if (newValue === 0) {
                    neuronDiv.classList.remove('bg-green-300');
                    neuronDiv.classList.add('bg-white');
                } else {
                    neuronDiv.classList.add('bg-green-300');
                    neuronDiv.classList.remove('bg-white');
                }
            };

            function sleep(ms) {
                return new Promise(resolve => setTimeout(resolve, ms));
            }

            // --- Event Listeners ---
            document.getElementById('propagate-btn').addEventListener('click', forwardPropagate);
            document.getElementById('reset-btn').addEventListener('click', resetAll);
            window.addEventListener('resize', () => {
                drawConnections();
                createWeightSliders();
            });

            // --- Start ---
            initialize();
        });
    </script>
</body>
</html>

