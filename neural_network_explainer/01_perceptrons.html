<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Visualisation de l'Algorithme Perceptron</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { font-family: 'Inter', sans-serif; }
        canvas { background-color: #f7fafc; }
        /* Style for slider thumbs */
        input[type=range]::-webkit-slider-thumb { -webkit-appearance: none; appearance: none; width: 20px; height: 20px; background: #3b82f6; cursor: pointer; border-radius: 50%; }
        input[type=range]::-moz-range-thumb { width: 20px; height: 20px; background: #3b82f6; cursor: pointer; border-radius: 50%; }
    </style>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
</head>
<body class="bg-gray-200 flex flex-col items-center justify-center min-h-screen p-4">

    <div class="w-full max-w-5xl bg-white rounded-xl shadow-2xl p-6 md:p-8">
        <header class="text-center mb-6">
            <h1 class="text-3xl md:text-4xl font-bold text-gray-800">Algorithme du Perceptron</h1>
            <p class="text-gray-600 mt-2">Visualisation interactive de l'apprentissage d'une frontière de décision linéaire.</p>
        </header>

        <!-- Onglets -->
        <div class="mb-4 border-b border-gray-200">
            <ul class="flex flex-wrap -mb-px text-sm font-medium text-center" id="tabsContainer">
                <li class="mr-2">
                    <button class="inline-block p-4 border-b-2 rounded-t-lg" id="tab-visualisation" type="button">Visualisation</button>
                </li>
                <li class="mr-2">
                    <button class="inline-block p-4 border-b-2 rounded-t-lg" id="tab-explication" type="button">Explication (y = mx + c)</button>
                </li>
            </ul>
        </div>

        <!-- Contenu des onglets -->
        <div id="visualisationContent">
            <div class="grid grid-cols-1 lg:grid-cols-3 gap-6">
                <!-- Colonne de visualisation -->
                <div class="lg:col-span-2 rounded-lg overflow-hidden border-2 border-gray-300">
                    <canvas id="perceptronCanvas" width="600" height="600"></canvas>
                </div>

                <!-- Colonne de contrôle -->
                <div class="flex flex-col justify-between bg-gray-50 p-6 rounded-lg border border-gray-200">
                    <div>
                        <h2 class="text-xl font-bold text-gray-700 mb-4">Contrôles</h2>
                        <div class="space-y-4">
                            <div class="grid grid-cols-2 gap-3">
                                 <button id="startButton" class="w-full bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded-lg transition-transform transform hover:scale-105 shadow-md">Démarrer</button>
                                <button id="stopButton" class="w-full bg-red-500 hover:bg-red-600 text-white font-bold py-2 px-4 rounded-lg transition-transform transform hover:scale-105 shadow-md" disabled>Arrêter</button>
                            </div>
                             <button id="resetButton" class="w-full bg-gray-700 hover:bg-gray-800 text-white font-bold py-2 px-4 rounded-lg transition-transform transform hover:scale-105 shadow-md">Réinitialiser</button>
                            <button id="stepButton" class="w-full bg-green-500 hover:bg-green-600 text-white font-bold py-2 px-4 rounded-lg transition-transform transform hover:scale-105 shadow-md">Étape Suivante</button>
                        </div>
                        <div class="mt-6 space-y-4">
                            <div>
                                <label for="learningRate" class="block text-sm font-medium text-gray-700">Taux d'apprentissage (η)</label>
                                <input type="range" id="learningRate" min="0.01" max="1" step="0.01" value="0.1" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer">
                                <span id="lrValue" class="text-sm text-gray-500 text-center block mt-1">0.1</span>
                            </div>
                            <div>
                                <label for="animationSpeed" class="block text-sm font-medium text-gray-700">Vitesse d'animation</label>
                                <input type="range" id="animationSpeed" min="0" max="200" step="1" value="150" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer">
                                <span id="speedValue" class="text-sm text-gray-500 text-center block mt-1">Normal</span>
                            </div>
                        </div>
                    </div>
                    <div class="mt-6 pt-6 border-t border-gray-200">
                         <h3 class="text-lg font-bold text-gray-700 mb-3">État de l'Apprentissage</h3>
                         <div class="space-y-2 text-sm bg-white p-3 rounded-md shadow-inner">
                            <p><strong>Époque :</strong> <span id="epochDisplay" class="font-mono text-blue-600">0</span></p>
                            <p><strong>Poids (w) :</strong> <span id="weightsDisplay" class="font-mono text-blue-600">[0.00, 0.00]</span></p>
                            <p><strong>Biais (b) :</strong> <span id="biasDisplay" class="font-mono text-blue-600">0.00</span></p>
                            <p><strong>Statut :</strong> <span id="statusDisplay" class="font-semibold text-red-500">En attente</span></p>
                         </div>
                    </div>
                </div>
            </div>
        </div>

        <div id="explicationContent" class="hidden p-6 bg-gray-50 rounded-lg border border-gray-200">
            <div class="grid grid-cols-1 lg:grid-cols-2 gap-8">
                <!-- Colonne Théorique -->
                <div>
                    <h2 class="text-2xl font-bold text-gray-800 mb-4">Le lien avec <code>y = mx + c</code></h2>
                    <div class="bg-white p-4 rounded-md shadow-inner space-y-3">
                        <p>1. L'équation du Perceptron pour la frontière est :</p>
                        <code class="block text-center bg-gray-100 p-2 rounded">(poids_x * x) + (poids_y * y) + biais = 0</code>
                        <p class="mt-4">2. En isolant 'y', on obtient :</p>
                        <code class="block text-center bg-gray-100 p-2 rounded">y = (-poids_x / poids_y) * x - (biais / poids_y)</code>
                        <p class="mt-4">3. On voit que :</p>
                        <ul class="list-disc list-inside bg-blue-50 p-3 rounded">
                            <li>La pente <strong>m</strong> = <code>-poids_x / poids_y</code></li>
                            <li>L'ordonnée à l'origine <strong>c</strong> = <code>-biais / poids_y</code></li>
                        </ul>
                    </div>
                    <div class="mt-6">
                        <h3 class="text-xl font-bold text-gray-700 mb-3">Valeurs du Perceptron :</h3>
                        <div class="space-y-2 text-sm bg-white p-3 rounded-md shadow-inner">
                            <p><strong>Poids (w) :</strong> <span class="font-mono text-blue-600" id="weightsDisplay-exp">[0.00, 0.00]</span></p>
                            <p><strong>Biais (b) :</strong> <span class="font-mono text-blue-600" id="biasDisplay-exp">0.00</span></p>
                            <hr class="my-2">
                            <p><strong>Pente (m) calculée :</strong> <span id="slopeDisplay" class="font-mono text-green-600 font-bold">...</span></p>
                            <p><strong>Ordonnée (c) calculée :</strong> <span id="interceptDisplay" class="font-mono text-green-600 font-bold">...</span></p>
                        </div>
                    </div>
                </div>
                <!-- Colonne Interactive -->
                <div>
                     <h2 class="text-2xl font-bold text-gray-800 mb-4">Jouez avec l'équation</h2>
                     <div class="rounded-lg overflow-hidden border-2 border-gray-300">
                        <canvas id="interactiveGraphCanvas" width="400" height="400"></canvas>
                     </div>
                     <div class="mt-4 space-y-3">
                        <div>
                             <label for="m_slider" class="block text-sm font-medium text-gray-700">Pente (m)</label>
                             <input type="range" id="m_slider" min="-5" max="5" step="0.1" value="1" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer">
                        </div>
                         <div>
                             <label for="c_slider" class="block text-sm font-medium text-gray-700">Ordonnée à l'origine (c)</label>
                             <input type="range" id="c_slider" min="-5" max="5" step="0.1" value="0.5" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer">
                        </div>
                        <div id="equationDisplay" class="text-center font-mono text-lg bg-gray-100 p-3 rounded-md">
                            y = 1.00x + 0.50
                        </div>
                     </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // DOM Elements
        const canvas = document.getElementById('perceptronCanvas');
        const ctx = canvas.getContext('2d');
        const startButton = document.getElementById('startButton');
        const stopButton = document.getElementById('stopButton');
        const resetButton = document.getElementById('resetButton');
        const stepButton = document.getElementById('stepButton');
        const learningRateSlider = document.getElementById('learningRate');
        const lrValueSpan = document.getElementById('lrValue');
        const animationSpeedSlider = document.getElementById('animationSpeed');
        const speedValueSpan = document.getElementById('speedValue');
        const epochDisplay = document.getElementById('epochDisplay');
        const weightsDisplay = document.getElementById('weightsDisplay');
        const biasDisplay = document.getElementById('biasDisplay');
        const statusDisplay = document.getElementById('statusDisplay');
        const tabVisualisation = document.getElementById('tab-visualisation');
        const tabExplication = document.getElementById('tab-explication');
        const vizContent = document.getElementById('visualisationContent');
        const expContent = document.getElementById('explicationContent');
        const weightsDisplayExp = document.getElementById('weightsDisplay-exp');
        const biasDisplayExp = document.getElementById('biasDisplay-exp');
        const slopeDisplay = document.getElementById('slopeDisplay');
        const interceptDisplay = document.getElementById('interceptDisplay');
        const interactiveCanvas = document.getElementById('interactiveGraphCanvas');
        const interactiveCtx = interactiveCanvas.getContext('2d');
        const mSlider = document.getElementById('m_slider');
        const cSlider = document.getElementById('c_slider');
        const equationDisplay = document.getElementById('equationDisplay');

        // State & Constants
        const pointRadius = 6, numPoints = 100;
        let points = [], weights = [0, 0], bias = 0, learningRate = 0.1, animationDelay = 50;
        let lastUpdateTime = 0, epoch = 0, currentPointIndex = 0;
        let animationFrameId, isRunning = false;
        const colorClass0 = '#f59e0b', colorClass1 = '#3b82f6', colorCurrentPoint = '#ef4444', colorLine = '#1f2937';

        // --- Perceptron Algorithm ---
        const activate = sum => sum >= 0 ? 1 : 0;
        const predict = point => activate(point.x * weights[0] + point.y * weights[1] + bias);

        function trainStep() {
            if (points.length === 0) return;
            const point = points[currentPointIndex];
            const error = point.label - predict(point);
            if (error !== 0) {
                weights[0] += learningRate * error * point.x;
                weights[1] += learningRate * error * point.y;
                bias += learningRate * error;
                statusDisplay.textContent = 'Correction...';
                statusDisplay.className = 'font-semibold text-yellow-500';
            }
            currentPointIndex = (currentPointIndex + 1) % points.length;
            if (currentPointIndex === 0) {
                epoch++;
                if (checkConvergence()) {
                    stopTraining();
                    statusDisplay.textContent = 'Converged!';
                    statusDisplay.className = 'font-semibold text-green-500';
                }
            }
            draw();
            updateInfo();
        }

        const checkConvergence = () => points.every(p => predict(p) === p.label);

        // --- Perceptron Drawing ---
        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawBackgroundRegions();
            drawDecisionBoundary();
            drawPoints();
        }

        function drawBackgroundRegions() {
            const res = 10;
            for (let i = 0; i < canvas.width; i += res) {
                for (let j = 0; j < canvas.height; j += res) {
                    const x = (i / canvas.width) * 2 - 1;
                    const y = -((j / canvas.height) * 2 - 1);
                    ctx.fillStyle = predict({ x, y }) === 1 ? 'rgba(59, 130, 246, 0.1)' : 'rgba(245, 158, 11, 0.1)';
                    ctx.fillRect(i, j, res, res);
                }
            }
        }

        function drawPoints() {
            points.forEach((p, index) => {
                const canvasX = (p.x + 1) / 2 * canvas.width;
                const canvasY = (-p.y + 1) / 2 * canvas.height;
                ctx.beginPath();
                ctx.arc(canvasX, canvasY, pointRadius, 0, 2 * Math.PI);
                ctx.fillStyle = p.label === 1 ? colorClass1 : colorClass0;
                ctx.fill();
                if (index === currentPointIndex && isRunning) {
                    ctx.strokeStyle = colorCurrentPoint;
                    ctx.lineWidth = 3;
                    ctx.stroke();
                }
            });
        }

        function drawDecisionBoundary() {
            if (Math.abs(weights[1]) < 1e-3) return;
            ctx.beginPath();
            ctx.strokeStyle = colorLine;
            ctx.lineWidth = 3;
            const y1 = (-weights[0] * (-1) - bias) / weights[1];
            const y2 = (-weights[0] * (1) - bias) / weights[1];
            ctx.moveTo(0, (-y1 + 1) / 2 * canvas.height);
            ctx.lineTo(canvas.width, (-y2 + 1) / 2 * canvas.height);
            ctx.stroke();
        }

        // --- Interactive Graph Drawing ---
        function drawInteractiveGraph() {
            const w = interactiveCanvas.width, h = interactiveCanvas.height;
            const m = parseFloat(mSlider.value), c = parseFloat(cSlider.value);
            const xRange = 10, yRange = 10;

            interactiveCtx.clearRect(0, 0, w, h);

            // Draw grid and axes
            interactiveCtx.strokeStyle = '#e5e7eb';
            interactiveCtx.lineWidth = 1;
            for (let i = 0; i <= w; i += w/xRange) { interactiveCtx.beginPath(); interactiveCtx.moveTo(i, 0); interactiveCtx.lineTo(i, h); interactiveCtx.stroke(); }
            for (let j = 0; j <= h; j += h/yRange) { interactiveCtx.beginPath(); interactiveCtx.moveTo(0, j); interactiveCtx.lineTo(w, j); interactiveCtx.stroke(); }
            interactiveCtx.strokeStyle = '#9ca3af';
            interactiveCtx.beginPath(); interactiveCtx.moveTo(w/2, 0); interactiveCtx.lineTo(w/2, h); interactiveCtx.stroke();
            interactiveCtx.beginPath(); interactiveCtx.moveTo(0, h/2); interactiveCtx.lineTo(w, h/2); interactiveCtx.stroke();

            // Draw line y = mx + c
            interactiveCtx.beginPath();
            interactiveCtx.strokeStyle = '#16a34a'; // green-600
            interactiveCtx.lineWidth = 3;
            const toCanvasX = x => (x + xRange/2) * (w / xRange);
            const toCanvasY = y => (-y + yRange/2) * (h / yRange);

            let y1 = m * (-xRange/2) + c;
            let y2 = m * (xRange/2) + c;

            interactiveCtx.moveTo(toCanvasX(-xRange/2), toCanvasY(y1));
            interactiveCtx.lineTo(toCanvasX(xRange/2), toCanvasY(y2));
            interactiveCtx.stroke();

            equationDisplay.textContent = `y = ${m.toFixed(2)}x ${c >= 0 ? '+' : '-'} ${Math.abs(c).toFixed(2)}`;
        }

        // --- UI Update & Controls ---
        function updateInfo() {
            const weightsText = `[${weights[0].toFixed(2)}, ${weights[1].toFixed(2)}]`;
            const biasText = bias.toFixed(2);
            epochDisplay.textContent = epoch;
            weightsDisplay.textContent = weightsText;
            biasDisplay.textContent = biasText;
            weightsDisplayExp.textContent = weightsText;
            biasDisplayExp.textContent = biasText;

            if (Math.abs(weights[1]) > 1e-3) {
                slopeDisplay.textContent = (-weights[0] / weights[1]).toFixed(2);
                interceptDisplay.textContent = (-bias / weights[1]).toFixed(2);
            } else {
                slopeDisplay.textContent = '∞';
                interceptDisplay.textContent = 'N/A';
            }
        }

        function updateSpeedLabel(value) {
            if (value < 50) speedValueSpan.textContent = 'Très lent';
            else if (value < 100) speedValueSpan.textContent = 'Lent';
            else if (value < 150) speedValueSpan.textContent = 'Normal';
            else speedValueSpan.textContent = 'Rapide';
        }

        function startTraining() {
            if (isRunning) return;
            isRunning = true;
            [startButton, stepButton, learningRateSlider, animationSpeedSlider].forEach(el => el.disabled = true);
            stopButton.disabled = false;
            statusDisplay.textContent = 'Apprentissage...';
            statusDisplay.className = 'font-semibold text-blue-500 animate-pulse';

            lastUpdateTime = performance.now();
            (function loop(currentTime) {
                animationFrameId = requestAnimationFrame(loop);
                if (currentTime - lastUpdateTime > animationDelay) {
                    trainStep();
                    lastUpdateTime = currentTime;
                }
            })(lastUpdateTime);
        }

        function stopTraining() {
            if (!isRunning) return;
            isRunning = false;
            cancelAnimationFrame(animationFrameId);
            [startButton, stepButton, learningRateSlider, animationSpeedSlider].forEach(el => el.disabled = false);
            stopButton.disabled = true;
            if(statusDisplay.textContent !== 'Converged!') {
                 statusDisplay.textContent = 'Stoppé';
                 statusDisplay.className = 'font-semibold text-gray-500';
            }
            draw();
        }

        function reset() {
            stopTraining();
            weights = [0, 0]; bias = 0; epoch = 0; currentPointIndex = 0;
            const m = (Math.random() - 0.5) * 4, c = (Math.random() - 0.5) * 0.5;
            points = Array.from({length: numPoints}, () => {
                const x = Math.random() * 2 - 1, y = Math.random() * 2 - 1;
                return { x, y, label: y > m * x + c ? 1 : 0 };
            });
            statusDisplay.textContent = 'En attente';
            statusDisplay.className = 'font-semibold text-red-500';
            updateInfo();
            const speed = parseInt(animationSpeedSlider.value);
            animationDelay = 200 - speed;
            updateSpeedLabel(speed);
            draw();
        }

        function setupTabs() {
            const tabs = [tabVisualisation, tabExplication], contents = [vizContent, expContent];
            function switchTab(clickedTab) {
                tabs.forEach((tab, index) => {
                    const active = tab === clickedTab;
                    tab.classList.toggle('border-blue-600', active);
                    tab.classList.toggle('text-blue-600', active);
                    tab.classList.toggle('border-transparent', !active);
                    tab.classList.toggle('hover:text-gray-600', !active);
                    tab.classList.toggle('hover:border-gray-300', !active);
                    contents[index].classList.toggle('hidden', !active);
                });
                if (clickedTab === tabExplication) drawInteractiveGraph();
            }
            tabs.forEach(tab => tab.addEventListener('click', () => switchTab(tab)));
            switchTab(tabVisualisation);
        }

        // --- Event Listeners ---
        startButton.addEventListener('click', startTraining);
        stopButton.addEventListener('click', stopTraining);
        resetButton.addEventListener('click', reset);
        stepButton.addEventListener('click', () => !isRunning && trainStep());
        learningRateSlider.addEventListener('input', e => {
            learningRate = parseFloat(e.target.value);
            lrValueSpan.textContent = learningRate.toFixed(2);
        });
        animationSpeedSlider.addEventListener('input', e => {
            const value = parseInt(e.target.value);
            animationDelay = 200 - value;
            updateSpeedLabel(value);
        });
        mSlider.addEventListener('input', drawInteractiveGraph);
        cSlider.addEventListener('input', drawInteractiveGraph);

        // --- Initialisation ---
        setupTabs();
        window.onload = reset;
    </script>
</body>
</html>

