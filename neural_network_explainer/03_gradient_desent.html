<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Neural Network Training Loop</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f4f8;
        }
        .neuron {
            transition: all 0.3s ease-in-out;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }
        .connection {
            transition: stroke 0.3s ease-in-out, stroke-width 0.3s ease;
        }
        .info-box {
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        #plot-canvas {
            border-radius: 0.75rem;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        }
    </style>
</head>
<body class="bg-gray-50 text-gray-800 antialiased">
    <div class="min-h-screen flex flex-col items-center justify-center p-4 lg:p-8">

        <header class="text-center mb-8">
            <h1 class="text-4xl lg:text-5xl font-bold text-gray-900">Neural Network Training Loop</h1>
            <p class="text-lg text-gray-600 mt-2 max-w-3xl mx-auto">Visualizing gradient descent and weight updates for a binary classification task.</p>
        </header>

        <div class="w-full max-w-7xl mx-auto grid grid-cols-1 lg:grid-cols-3 gap-8">

            <!-- Visualization Column -->
            <div class="lg:col-span-2 flex flex-col gap-8">
                <!-- 2D Data Plot -->
                <div class="bg-white p-4 rounded-xl shadow-lg">
                    <h3 class="text-lg font-semibold text-center mb-2">2D Feature Data & Decision Boundary</h3>
                    <canvas id="plot-canvas" width="600" height="400"></canvas>
                </div>

                <!-- Neural Network Diagram -->
                 <div id="visualization" class="relative w-full flex-grow flex justify-center items-center h-[250px] bg-white p-4 rounded-xl shadow-lg">
                    <svg id="svg-canvas" class="absolute w-full h-full top-0 left-0 z-0" style="overflow: visible;"></svg>
                    <div class="relative z-10 w-full flex justify-between items-center px-8">
                        <!-- Input -->
                        <div id="input-layer" class="flex flex-col gap-4 text-center">
                            <h4 class="font-semibold">Input</h4>
                            <div id="input-neuron-0" class="neuron-container"><div class="neuron w-12 h-12 rounded-full bg-green-200 flex items-center justify-center text-sm font-bold">x₁</div></div>
                            <div id="input-neuron-1" class="neuron-container"><div class="neuron w-12 h-12 rounded-full bg-green-200 flex items-center justify-center text-sm font-bold">x₂</div></div>
                        </div>
                        <!-- Hidden -->
                        <div id="hidden-layer" class="flex flex-col gap-2 text-center">
                             <h4 class="font-semibold">Hidden</h4>
                             <div id="hidden-neuron-0" class="neuron-container"><div class="neuron w-14 h-14 rounded-full bg-blue-200 flex items-center justify-center text-sm font-bold"><span class="value">0.0</span></div></div>
                        </div>
                        <!-- Output -->
                        <div id="output-layer" class="flex flex-col gap-4 text-center">
                            <h4 class="font-semibold">Output</h4>
                            <div id="output-neuron-0" class="neuron-container"><div class="neuron w-16 h-16 rounded-full bg-purple-200 flex items-center justify-center text-sm font-bold"><span class="value">0.0</span></div></div>
                        </div>
                    </div>
                 </div>
            </div>

            <!-- Controls and Explanation Panel -->
            <div class="w-full">
                <div class="info-box bg-white/80 rounded-2xl shadow-lg p-6 sticky top-8">
                    <h3 class="text-xl font-bold mb-4">Training Controls</h3>
                    <div class="space-y-4">
                        <div>
                            <label for="lr-slider" class="block text-sm font-medium text-gray-700">Learning Rate: <span id="lr-value">0.1</span></label>
                            <input id="lr-slider" type="range" min="0.01" max="1" step="0.01" value="0.1" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer">
                        </div>
                         <div class="flex flex-col gap-3">
                            <button id="train-btn" class="w-full bg-green-500 hover:bg-green-600 text-white font-bold py-3 px-4 rounded-lg text-lg transition duration-300 shadow-md">Start Training</button>
                            <button id="reset-btn" class="w-full bg-gray-500 hover:bg-gray-600 text-white font-bold py-2 px-4 rounded-lg transition duration-300">New Data & Reset</button>
                        </div>
                        <p class="text-sm text-gray-500 text-center">Epoch: <span id="epoch-count">0</span> | Loss: <span id="loss-value">N/A</span></p>
                    </div>

                    <h3 class="text-xl font-bold mt-6 mb-4">Gradient Descent Explained</h3>
                    <div id="math-explanation" class="text-gray-700 space-y-2 font-mono text-xs break-all bg-gray-50 p-3 rounded-lg">
                        <p class="text-gray-500">Calculations will appear here during training...</p>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
    document.addEventListener('DOMContentLoaded', () => {
        // --- Canvas & DOM Elements ---
        const canvas = document.getElementById('plot-canvas');
        const ctx = canvas.getContext('2d');
        const svgCanvas = document.getElementById('svg-canvas');

        const lrSlider = document.getElementById('lr-slider');
        const lrValueSpan = document.getElementById('lr-value');
        const trainBtn = document.getElementById('train-btn');
        const resetBtn = document.getElementById('reset-btn');
        const epochSpan = document.getElementById('epoch-count');
        const lossSpan = document.getElementById('loss-value');
        const mathDiv = document.getElementById('math-explanation');

        // --- Network & Training State ---
        let weights = {};
        let data = [];
        let learningRate = 0.1;
        let isTraining = false;
        let epoch = 0;

        const neuronElements = {
            input: [document.getElementById('input-neuron-0'), document.getElementById('input-neuron-1')],
            hidden: [document.getElementById('hidden-neuron-0')],
            output: [document.getElementById('output-neuron-0')]
        };
        let connections = [];

        // --- Core Functions ---

        function initialize() {
            generateData();
            initializeWeights();
            createConnections();
            drawAll();
        }

        function generateData() {
            data = [];
            for (let i = 0; i < 50; i++) {
                // Class 0
                data.push({ x1: Math.random() * 0.4, x2: Math.random() * 0.4, y: 0 });
                // Class 1
                data.push({ x1: 0.6 + Math.random() * 0.4, x2: 0.6 + Math.random() * 0.4, y: 1 });
            }
        }

        function initializeWeights() {
            weights = {
                w_i0_h0: Math.random() * 2 - 1, w_i1_h0: Math.random() * 2 - 1, b_h0: 0,
                w_h0_o0: Math.random() * 2 - 1, b_o0: 0
            };
        }

        // --- Sigmoid and its derivative ---
        function sigmoid(x) { return 1 / (1 + Math.exp(-x)); }
        function sigmoidDerivative(x) { return x * (1 - x); }

        // --- Forward Pass ---
        function forwardPass(x1, x2) {
            const z_h0 = weights.w_i0_h0 * x1 + weights.w_i1_h0 * x2 + weights.b_h0;
            const a_h0 = sigmoid(z_h0);
            const z_o0 = weights.w_h0_o0 * a_h0 + weights.b_o0;
            const a_o0 = sigmoid(z_o0);
            return { a_h0, a_o0 };
        }

        // --- Training Loop ---
        async function trainingStep() {
            if (!isTraining) return;

            let totalLoss = 0;

            // Shuffle data
            data.sort(() => Math.random() - 0.5);

            for(const point of data) {
                // 1. Forward Pass
                const { a_h0, a_o0 } = forwardPass(point.x1, point.x2);

                // 2. Calculate Loss (Mean Squared Error) and Error term
                const error = point.y - a_o0;
                totalLoss += error * error;

                // 3. Backpropagation (Calculate gradients)
                const delta_output = error * sigmoidDerivative(a_o0);
                const error_hidden = delta_output * weights.w_h0_o0;
                const delta_hidden = error_hidden * sigmoidDerivative(a_h0);

                // 4. Update Weights (Gradient Descent)
                weights.w_h0_o0 += a_h0 * delta_output * learningRate;
                weights.b_o0 += delta_output * learningRate;
                weights.w_i0_h0 += point.x1 * delta_hidden * learningRate;
                weights.w_i1_h0 += point.x2 * delta_hidden * learningRate;
                weights.b_h0 += delta_hidden * learningRate;
            }

            epoch++;
            const avgLoss = totalLoss / data.length;

            // Update UI
            epochSpan.textContent = epoch;
            lossSpan.textContent = avgLoss.toFixed(4);
            updateMath(data[0].y, forwardPass(data[0].x1, data[0].x2).a_o0, avgLoss);
            drawAll();

            if (isTraining) {
                requestAnimationFrame(trainingStep);
            }
        }

        // --- Drawing and Visualization ---

        function drawAll() {
            drawPlot();
            drawConnections();
            updateConnectionStyles();
        }

        function drawPlot() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            const w = canvas.width;
            const h = canvas.height;

            // Draw decision boundary
            ctx.beginPath();

            // Calculate the line's y-position in data coordinates (0 to 1) for x=0 and x=1
            const y1_data = (-weights.w_i0_h0 * 0 - weights.b_h0) / weights.w_i1_h0;
            const y2_data = (-weights.w_i0_h0 * 1 - weights.b_h0) / weights.w_i1_h0;

            // Convert data coordinates to canvas coordinates, inverting the Y-axis
            // so that y=0 is at the bottom, matching the data point plotting.
            const y1_canvas = h - (y1_data * h);
            const y2_canvas = h - (y2_data * h);

            ctx.strokeStyle = '#f87171';
            ctx.lineWidth = 3;
            ctx.moveTo(0, y1_canvas);
            ctx.lineTo(w, y2_canvas);
            ctx.stroke();

            // Draw data points
            data.forEach(p => {
                ctx.beginPath();
                ctx.arc(p.x1 * w, h - p.x2 * h, 5, 0, Math.PI * 2);
                ctx.fillStyle = p.y === 0 ? 'rgb(59, 130, 246)' : 'rgb(239, 68, 68)';
                ctx.fill();
            });
        }

        function createConnections() {
            connections = [
                { id: 'w_i0_h0', from: neuronElements.input[0], to: neuronElements.hidden[0] },
                { id: 'w_i1_h0', from: neuronElements.input[1], to: neuronElements.hidden[0] },
                { id: 'w_h0_o0', from: neuronElements.hidden[0], to: neuronElements.output[0] }
            ];
        }

        function drawConnections() {
            const viz = document.getElementById('visualization');
            svgCanvas.innerHTML = '';
            const vizRect = viz.getBoundingClientRect();
            connections.forEach(conn => {
                const fromRect = conn.from.getBoundingClientRect();
                const toRect = conn.to.getBoundingClientRect();
                const x1 = fromRect.left + fromRect.width / 2 - vizRect.left;
                const y1 = fromRect.top + fromRect.height / 2 - vizRect.top;
                const x2 = toRect.left + toRect.width / 2 - vizRect.left;
                const y2 = toRect.top + toRect.height / 2 - vizRect.top;
                const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                line.setAttribute('x1', x1); line.setAttribute('y1', y1);
                line.setAttribute('x2', x2); line.setAttribute('y2', y2);
                line.classList.add('connection');
                svgCanvas.appendChild(line);
                conn.el = line;
            });
        }

        function updateConnectionStyles() {
            connections.forEach(conn => {
                if (!conn.el) return;
                const weight = weights[conn.id];
                const width = Math.min(Math.abs(weight), 5) + 1;
                const color = weight > 0 ? '#22c55e' : '#ef4444';
                conn.el.setAttribute('stroke-width', width);
                conn.el.setAttribute('stroke', color);
            });
            // Update neuron values (from last forward pass for visualization)
            const {a_h0, a_o0} = forwardPass(0.5, 0.5); // use a sample point
            neuronElements.hidden[0].querySelector('.value').textContent = a_h0.toFixed(2);
            neuronElements.output[0].querySelector('.value').textContent = a_o0.toFixed(2);
        }

        function updateMath(y_true, y_pred, loss) {
            mathDiv.innerHTML = `
                <p>Loss = (y_true - y_pred)²</p>
                <p class="text-green-600">= (${y_true} - ${y_pred.toFixed(2)})² = ${loss.toFixed(3)}</p>
                <p class="mt-2">Δw = α * ∇Loss</p>
                <p class="text-blue-600">Weights are adjusted to minimize this loss value.</p>
                <p class="mt-2">w_new = w_old - α * ∂Loss/∂w</p>
            `;
        }

        // --- Event Handlers ---
        trainBtn.addEventListener('click', () => {
            if (isTraining) {
                isTraining = false;
                trainBtn.textContent = 'Start Training';
                trainBtn.classList.remove('bg-red-500', 'hover:bg-red-600');
                trainBtn.classList.add('bg-green-500', 'hover:bg-green-600');
            } else {
                isTraining = true;
                trainBtn.textContent = 'Stop Training';
                trainBtn.classList.remove('bg-green-500', 'hover:bg-green-600');
                trainBtn.classList.add('bg-red-500', 'hover:bg-red-600');
                trainingStep();
            }
        });

        resetBtn.addEventListener('click', () => {
             if (isTraining) { // Stop training if it's running
                isTraining = false;
                trainBtn.textContent = 'Start Training';
                trainBtn.classList.remove('bg-red-500', 'hover:bg-red-600');
                trainBtn.classList.add('bg-green-500', 'hover:bg-green-600');
            }
            epoch = 0;
            epochSpan.textContent = '0';
            lossSpan.textContent = 'N/A';
            mathDiv.innerHTML = '<p class="text-gray-500">Calculations will appear here...</p>';
            initialize();
        });

        lrSlider.addEventListener('input', (e) => {
            learningRate = parseFloat(e.target.value);
            lrValueSpan.textContent = learningRate.toFixed(2);
        });

        window.addEventListener('resize', drawAll);

        // --- Initial Call ---
        initialize();
    });
    </script>
</body>
</html>


